<!-- ## Orientation: -->

## What to expect

A direct guide to the basics of web-development and coding; but you already knew that.

Though we’ll go quickly, providing a foundation upon which you are expected to explore.

First by building your own website using HTML, CSS & JavaScript; then secondly by building scrapers.

After this you will be introduced to examples of web servers and web clients.

And you are encouraged to use these as models and building blocks for your own ideas.

> QN: the purpose of first building an HTML, CSS & JavaScript website is not for this to be your end portfolio site. Rather, it is meant as a first step toward understanding how web sites, and web applications, work.

> QN: About cheating. Copying parts of code, then implementing them in your project is an unspoken path to learning to code. Copy the code, try to apply it, see how it breaks, and then fix your own implementation.

What we want to avoid is what is known as kitty-scripting; which is copying entire chunks of code, or entire applications, with no idea how the code works. Beyond lacking integrity, it does nothing for one’s learning.

Moving on.


## Course Objectives

You read the following on the Gumroad page perhaps,



+   **An introduction to the Linux command-line environment**
+   **Building websites with HTML, CSS & JavaScript**
+   **Using Python to build web scrapers**

We will walk you through every one of these objectives.

Then you need to be able to put things together; though we also give you a community to help you find the answers to your questions. (Along with models to mimic and compare.)

*What if web-development isn’t your passion?!?* Yet something tech related is?

We just want you to get your foundations grounded. 

There is a final project, which can be on anything you wish. Through the community, or coaching, we gladly help you get closer to your tech goals.

The demonstration of aptitude is all one needs to get into the tech market; we want to give you tools to find your start in a niche, and then enable you to grow beyond!


## How does this work?

Outlined below are four primary steps that will be taken to attain a basic foundation of web development knowledge.

Each step is built on the steps before it; while from the first step you begin coding your personal website!

**Step 1:** HTML & CSS

**Step 2:** JavaScript

**Step 3:** Python / Scrapers

**Step 4:** The Full-Stack

By the end of our first four steps, you have all the knowledge and practice needed to begin learning *the full-stack*. 

We’ll outline the process for you as well!


## Personal Project

Your personal project is meant to demonstrate your ingenuity, passion and interests. And it doesn’t have to be a full-stack application either!

Though you need some mechanism, beyond your resume, to show aspects of who you are; as resumes are getting tiresome. Yes, they still have their use, that’s why we spend an entire week focusing on them in Everything You Need to Know.

Sometimes it is your personal projects, and social discussions that get someone to read your resume in the first place ;)

The best part is, like was said, you don’t need to build a full-stack application if you don’t want to!

We just want to identify an area of interest to you, begin exploring it, and provide some insight for others.

Do some research, and prepare a summation of what you’re learning; make it into a series of blog posts? Or maybe you want to learn about machine learning? Or Security?

Rebel Coding has the tools and community to get you started on either of those tracks; and we’re happy to do so.

This book is about getting started; and even for those interested in Security, knowing how the full-stack operates, and being familiar with Linux command line will put you leaps and bounds beyond your peers!

So let’s dig in!


## A Brief History of Computing

One of the best resources for learning about the history of computers, is the history of the Unix machine! Classy name, right?

Computers started by reading punchcards; though eventually a language was developed to make their processes more automated. That language was C, or the seed that would grow into the C language. The system it was designed to build and maintain was call Unix.

A gentleman named Bill Gates soon started developing another system using the BASIC language; and this is how Microsoft as we know it, began.

It is important to note that C and Unix were originally created through the funding of Bell South Atlantic Labs and various US Universities researching computer engineering. Through a few coincidences, and convenient mishaps, C & Unix were made open-source; anyone could read the source code!

Early on, Microsoft differentiated itself from this trend, opting to be built on proprietary code. And now open-source software is a growing norm, with open-source software available for most any application one might like to pursue. While the use of computers so common that a new problem has arisen.

What if one computer isn’t enough? 

Enter Kubernetes, and distributed systems!

But this is a conversation for another book.


## Low vs High Level Languages

High versus low level languages refers to the proximity to the assembly code.

What is the assembly code; that’s right above the 1’s & 0’s … the machine’s language.

We focus on some pretty high-level languages, Python (and bash, if you count it) are the lowest we will go in this book. 

Though Harvard’s EdX course introduces one to C as well, for those interested.

A primary difference between languages levels is their operations efficiency. 

Because the C language is closer to the assembly code, greater precision of action can be defined; creating more resource efficient processes.

For a higher-level language such as Python, many of the processes “under-the-hood” are already defined and can’t be easily adjusted. Interestingly enough, there are some efforts to improve this, see package Cython.

Python, Ruby, PHP, JavaScript